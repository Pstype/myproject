User prompt: Conway's Game of Life

function setup() {
  createCanvas(400, 400);
  background(255);
  frameRate(10);
  cells = Array(floor(width / 20));
  for (let i = 0; i < cells.length; i++) {
    cells[i] = Array(floor(height / 20));
    for (let j = 0; j < cells[i].length; j++) {
      cells[i][j] = floor(random(2));
    }
  }
}
function draw() {
  background(255);
  for (let i = 0; i < cells.length; i++) {
    for (let j = 0; j < cells[i].length; j++) {
      let x = i * 20;
      let y = j * 20;
      if (cells[i][j] == 1) {
        fill(0);
        stroke(0);
        rect(x, y, 20, 20);
      }
    }
  }
  let nextGen = Array(cells.length);
  for (let i = 0; i < cells.length; i++) {
    nextGen[i] = Array(cells[i].length);
    for (let j = 0; j < cells[i].length; j++) {
      let state = cells[i][j];
      let neighbours = countNeighbours(cells, i, j);
      if (state == 0 && neighbours == 3) {
        nextGen[i][j] = 1;
      } else if (state == 1 && (neighbours < 2 || neighbours > 3)) {
        nextGen[i][j] = 0;
      } else {
        nextGen[i][j] = state;
      }
    }
  }
  cells = nextGen;
}
function countNeighbours(cells, x, y) {
  let sum = 0;
  for (let i = -1; i < 2; i++) {
    for (let j = -1; j < 2; j++) {
      let col = (x + i + cells.length) % cells.length;
      let row = (y + j + cells[0].length) % cells[0].length;
      sum += cells[col][row];
    }
  }
  sum -= cells[x][y];
  return sum;
}


-----

User prompt: Conway's Game of Life

function setup() {
  createCanvas(400, 400);
  background(255);
  noLoop();
}
function draw() {
  let cellSize = 10;
  let rows = height / cellSize;
  let cols = width / cellSize;
  let prevGen = createPrevGen(rows, cols);
  let nextGen = createNextGen(rows, cols, prevGen);
  displayGrid(rows, cols, cellSize, nextGen);
}
function createPrevGen(rows, cols) {
  let prevGen = [];
  for (let i = 0; i < rows; i++) {
    prevGen[i] = [];
    for (let j = 0; j < cols; j++) {
      prevGen[i][j] = floor(random(2));
    }
  }
  return prevGen;
}
function createNextGen(rows, cols, prevGen) {
  let nextGen = [];
  for (let i = 0; i < rows; i++) {
    nextGen[i] = [];
    for (let j = 0; j < cols; j++) {
      let neighbours = countNeighbours(i, j, prevGen);
      if (prevGen[i][j] === 0 && neighbours === 3) {
        nextGen[i][j] = 1;
      } else if (prevGen[i][j] === 1 && (neighbours < 2 || neighbours > 3)) {
        nextGen[i][j] = 0;
      } else {
        nextGen[i][j] = prevGen[i][j];
      }
    }
  }
  return nextGen;
}
function countNeighbours(row, col, grid) {
  let sum = 0;
  for (let i = -1; i < 2; i++) {
    for (let j = -1; j < 2; j++) {
      let rowIndex = (row + i + grid.length) % grid.length;
      let colIndex = (col + j + grid[0].length) % grid[0].length;
      sum += grid[rowIndex][colIndex];
    }
  }
  sum -= grid[row][col];
  return sum;
}
function displayGrid(rows, cols, cellSize, grid) {
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] === 1) {
        fill(0);
      } else {
        fill(255);
      }
      rect(j * cellSize, i * cellSize, cellSize, cellSize);
    }
  }
}

-----

User prompt: Create a 2D flocking simulation
{
  id: 'chatcmpl-79EkqvwZE0rw2DeT2SVPiy1w8gpkj',
  object: 'chat.completion',
  created: 1682436024,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 76, completion_tokens: 323, total_tokens: 399 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: let flock;
function setup() {
  createCanvas(800, 600);
  flock = new Flock();
  for (let i = 0; i < 100; i++)
    flock.addBoid(new Boid(random(width), random(height)));
}
function draw() {
  background(51);
  flock.run();
}
class Boid {
  constructor(x, y) {
    this.position = createVector(x, y);
    this.velocity = p5.Vector.random2D();
    this.velocity.setMag(random(2, 4));
    this.acceleration = createVector();
    this.maxForce = 0.2;
    this.maxSpeed = 4;
  }
  show() {
    fill(255);
    noStroke();
    ellipse(this.position.x, this.position.y, 8, 8);
  }
  edges() {
    if (this.position.x > width) this.position.x = 0;
    else if (this.position.x < 0) this.position.x = width;
    if (this.position.y > height) this.position.y = 0;
    else if (this.position.y < 0) this.position.y = height;
  }
}
class Flock {
  constructor() {
    this.boids = [];
  }
  run() {
    for (let boid of this.boids) {
      boid.edges();
      boid.flock(this.boids);
      boid.update();
      boid.show();
    }
  }
  addBoid(boid) {
    this.boids.push(boid);
  }
}

-----

User prompt: 2D flocking animation
{
  id: 'chatcmpl-79FB1SMsgGh1m7CQxg5BX5tCpba5T',
  object: 'chat.completion',
  created: 1682437647,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 74, completion_tokens: 547, total_tokens: 621 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: const flock = [];

function setup() {
  createCanvas(800, 600);
  
  for(let i = 0; i < 100; i++) {
    flock.push(new Boid());
  }
}

function draw() {
  background(255);
  
  for(let boid of flock) {
    boid.flock(flock);
    boid.update();
    boid.edges();
    boid.show();
  }
}

class Boid {
  constructor() {
    this.position = createVector(random(width), random(height));
    this.velocity = p5.Vector.random2D();
    this.velocity.setMag(random(2, 4));
    this.acceleration = createVector();
    this.maxForce = 0.2;
    this.maxSpeed = 4;
  }
  
  flock(boids) {
    let alignment = createVector();
    let cohesion = createVector();
    let separation = createVector();
    
    let perceptionRadius = 50;
    let total = 0;
    
    for(let other of boids) {
      let distance = dist(this.position.x, this.position.y, other.position.x, other.position.y);
      
      if(other != this && distance < perceptionRadius) {
        alignment.add(other.velocity);
        cohesion.add(other.position);
        separation.add(p5.Vector.sub(this.position, other.position));
        total++;
      }
    }
    
    if(total > 0) {
      alignment.div(total);
      alignment.setMag(this.maxSpeed);
      alignment.sub(this.velocity);
      alignment.limit(this.maxForce);
      
      cohesion.div(total);
      cohesion.sub(this.position);
      cohesion.setMag(this.maxSpeed);
      cohesion.sub(this.velocity);
      cohesion.limit(this.maxForce);
      
      separation.div(total);
      separation.setMag(this.maxSpeed);
      separation.sub(this.velocity);
      separation.limit(this.maxForce);
    }
    
    this.acceleration.add(alignment);
    this.acceleration.add(cohesion);
    this.acceleration.add(separation);
  }
  
  update() {
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.maxSpeed);
    this.position.add(this.velocity);
    this.acceleration.mult(0);
  }
  
  show() {
    strokeWeight(8);
    stroke(55, 139, 255);
    point(this.position.x, this.position.y);
  }
  
  edges() {
    if(this.position.x > width) this.position.x = 0;
    else if(this.position.x < 0) this.position.x = width;
    
    if(this.position.y > height) this.position.y = 0;
    else if(this.position.y < 0) this.position.y = height;
  }
}

-----

User prompt: raining rainbow and horses
{
  id: 'chatcmpl-79FGBNEcLUJ0rpt4D7w7E0VCNN9bV',
  object: 'chat.completion',
  created: 1682437967,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 72, completion_tokens: 214, total_tokens: 286 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: const textInput = "raining rainbow and horses";

function setup() {
  createCanvas(400, 400);
  background(255);
}

function draw() {
  noStroke();
  let words = textInput.split(" ");
  let x = 0;
  let y = 20;
  for(let i = 0; i < words.length; i++) {
    if(words[i] === 'raining') {
      fill(100);
      ellipse(random(width), random(height), 10, 10);
    } else if(words[i] === 'rainbow') {
      fill(random(255), random(255), random(255));
      rect(x, y, 50, 50);
    } else if(words[i] === 'horses') {
      fill(0);
      rect(x, y + 60, 100, 20);
    }
    x += 60;
    if(x > width - 50) {
      x = 0;
      y += 100;
    }
  }
}

-----

User prompt: psychedelic mushroom trip
{
  id: 'chatcmpl-79FHJsl4r4Cb8WDkj17GpXs0m6rcV',
  object: 'chat.completion',
  created: 1682438037,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 71, completion_tokens: 85, total_tokens: 156 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: const psychedelicColors = ['purple', 'pink', 'blue', 'green', 'yellow'];
const mushroomSize = 50;

function setup() {
  createCanvas(500, 500);
}

function draw() {
  background('black');
  noStroke();
  let randomColor = random(psychedelicColors);
  fill(randomColor);
  ellipse(random(width), random(height), mushroomSize, mushroomSize);
}
User prompt: a scene with bouncing circles which change color gradually over time
{
  id: 'chatcmpl-79FIJCMeWmM3wcVh381EroJEMJI47',
  object: 'chat.completion',
  created: 1682438099,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 79, completion_tokens: 314, total_tokens: 393 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: function setup() {
  createCanvas(400, 400);
  colorMode(HSB);
  circles = [];
  for (let i = 0; i < 5; i++) {
    circles.push(new Circle(random(20, 380), random(20, 380)));
  }
}

function draw() {
  background(220);
  for (let i = 0; i < circles.length; i++) {
    circles[i].update();
    circles[i].display();
  }
}

class Circle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = random(20, 40);
    this.col = color(random(255), 255, 255);
    this.speedX = random(-3, 3);
    this.speedY = random(-3, 3);
  }

  update() {
    this.x += this.speedX;
    this.y += this.speedY;
    this.checkEdges();
    this.col = color(frameCount % 255, 255, 255);
  }

  display() {
    noStroke();
    fill(this.col);
    ellipse(this.x, this.y, this.r * 2);
  }

  checkEdges() {
    if (this.x > width - this.r || this.x < this.r) {
      this.speedX *= -1;
    }
    if (this.y > height - this.r || this.y < this.r) {
      this.speedY *= -1;
    }
  }
}

-----

User prompt: a basic game where a character can move around using arrow keys
{
  id: 'chatcmpl-79FcQrxK45eFRkgrGoKyIEwaIOyvU',
  object: 'chat.completion',
  created: 1682439346,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 80, completion_tokens: 159, total_tokens: 239 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: function setup() {
    createCanvas(400, 400);
}

let characterX = 200;
let characterY = 200;
let characterSpeed = 5;

function draw() {
    background(220);
    moveCharacter();
    drawCharacter();
}

function moveCharacter() {
    if (keyIsDown(LEFT_ARROW)) {
        characterX -= characterSpeed;
    }
    if (keyIsDown(RIGHT_ARROW)) {
        characterX += characterSpeed;
    }
    if (keyIsDown(UP_ARROW)) {
        characterY -= characterSpeed;
    }
    if (keyIsDown(DOWN_ARROW)) {
        characterY += characterSpeed;
    }
}

function drawCharacter() {
    ellipse(characterX, characterY, 50, 50);
}

-----

User prompt: something that uses perlin noise
{
  id: 'chatcmpl-79Fl1yPlZslHo31DAoKDboyqCxoQF',
  object: 'chat.completion',
  created: 1682439879,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 74, completion_tokens: 179, total_tokens: 253 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: const canvasWidth = 500;
const canvasHeight = 500;

let xoff = 0;
let yoff = 0;

function setup() {
  createCanvas(canvasWidth, canvasHeight);
}

function draw() {
  background(220);

  // Generate perlin noise values
  let noiseValueX = noise(xoff);
  let noiseValueY = noise(yoff);

  // Map noise values to canvas size
  let xPos = map(noiseValueX, 0, 1, 0, width);
  let yPos = map(noiseValueY, 0, 1, 0, height);

  // Draw ellipse at mapped positions
  ellipse(xPos, yPos, 50, 50);

  // Increment noise values for next frame
  xoff += 0.01;
  yoff += 0.01;
}

-----

User prompt: perlin noise ripples
{
  id: 'chatcmpl-79VVmWOtgwUht9OOMN0V3OEGLsx2Y',
  object: 'chat.completion',
  created: 1682500438,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 73, completion_tokens: 165, total_tokens: 238 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: const seed = 0.1;

function setup() {
  createCanvas(400, 400);
  frameRate(60);
  colorMode(RGB, 255);
}

function draw() {
  background(0);
  noStroke();
  loadPixels();
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let index = (x + y * width) * 4;
      let r = noise(x * seed, y * seed) * 255;
      pixels[index] = r;
      pixels[index + 1] = r;
      pixels[index + 2] = r;
      pixels[index + 3] = 255;
    }
  }
  updatePixels();
}
wait  - compiling...
event - compiled client and server successfully in 209 ms (213 modules)
wait  - compiling /api/generate (client and server)...
event - compiled successfully in 88 ms (52 modules)
User prompt: perlin noise moving waves calming
{
  id: 'chatcmpl-79VZ2v1ZlgqaOEl1PNrqEPlBDZbl7',
  object: 'chat.completion',
  created: 1682500640,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 74, completion_tokens: 118, total_tokens: 192 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: const noiseFactor = 0.05; 

function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(220);
  for (let x = 0; x <= width; x += 10) {
    let noiseVal = noise(x * noiseFactor, frameCount * noiseFactor);
    let y = map(noiseVal, 0, 1, height / 2 - 50, height / 2 + 50);
    stroke(0);
    line(x, y, x, height);
  }
}

-----

User prompt: perlin noise moving ripples, super zen
{
  id: 'chatcmpl-79Va2xmSgLSNOC1DK3eGS3NBXstzZ',
  object: 'chat.completion',
  created: 1682500702,
  model: 'gpt-3.5-turbo-0301',
  usage: { prompt_tokens: 77, completion_tokens: 229, total_tokens: 306 },
  choices: [ { message: [Object], finish_reason: 'stop', index: 0 } ]
}
Sent: const ripples = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  stroke(255);
  noFill();
  for (let i = 0; i < 10; i++) {
    ripples.push(new Ripple(random(width), random(height)));
  }
}

function draw() {
  background(0);
  for (let i = 0; i < ripples.length; i++) {
    ripples[i].update();
    ripples[i].display();
  }
}

class Ripple {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.r = 50;
    this.maxR = 500;
  }

  update() {
    this.r += noise(frameCount / 100, this.pos.y / 100) * 5;
    if (this.r > this.maxR) {
      this.r = 0;
      this.pos.x = random(width);
      this.pos.y = random(height);
    }
  }

  display() {
    ellipse(this.pos.x, this.pos.y, this.r, this.r / 2);
  }
}

-----
